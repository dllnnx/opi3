import javax.xml.parsers.DocumentBuilderFactory

plugins {
  id 'java'
  id 'war'
}

group 'org.example'

repositories {
  mavenCentral()
}

tasks.withType(JavaCompile).configureEach {
  options.encoding = 'UTF-8'
}

ext {
  junitVersion = '5.9.2'
  seleniumVersion = '4.32.0'
}

configurations {
  functionalTestImplementation.extendsFrom testImplementation
  functionalTestRuntimeOnly.extendsFrom testRuntimeOnly
}

sourceSets {
  main {
    java {
      srcDirs = ['src/main/java']
    }
  }

  functionalTest {
    java {
      java.srcDir file('src/functionalTest/java')
      resources.srcDir file('src/functionalTest/resources')
      compileClasspath += sourceSets.main.output + configurations.testRuntimeClasspath
      runtimeClasspath += output + compileClasspath
    }
  }
}

def srcDir = 'src/main/java'
def classesDir = layout.buildDirectory.dir("classes/java/main").get().asFile.absolutePath
def jarFile = layout.buildDirectory.file("libs/${project.name}.jar").get().asFile
def functionalSrcDir = 'src/functionalTest'
def functionalClassesDir = "$buildDir/classes/java/funcTest"

// опасности -^
// .get() получает результат сразу, те на момент конфигурации. то есть есть buildDir поменяется позже, то все будет плохо (некорректное значение).
// вместо этого можно
// def classesDir = layout.buildDirectory.dir("classes/java/main")
// и потом юзать classesDir.get().asFile внутри doLast {} или Exec таски

tasks.register("custom-compile") {
  group = "lab"
  description = "Компиляция исходных файлов проекта"

  inputs.files(fileTree(dir: srcDir, include: '**/*.java'))
  outputs.dir(classesDir)

  doLast {
    println "Compiling classes..."
    file(classesDir).mkdirs()

    def sources = fileTree(dir: srcDir, include: '**/*.java').files*.path
    def classpath = sourceSets.main.compileClasspath.asPath
    def cmd = ["javac", "-d", classesDir, "-cp", classpath] + sources
    exec {
      commandLine cmd
    }

    println "Compiled successfully."
  }
}


tasks.register("custom-build") {
  group = "lab"
  description = "Упаковка скомпилированных классов в исполняемый jar-архив"
  dependsOn("custom-compile")

  outputs.file(jarFile)

  doLast {
    println "Building jar..."
    file(jarFile.parent).mkdirs()

    exec {
      commandLine "jar", "cf", jarFile.absolutePath, "-C", classesDir, "."
    }

    println "Jar build successfully."
  }
}

tasks.register("custom-clean") {
  group = "lab"
  description = "Удаление скомпилированных классов проекта и всех временных файлов (если они есть)"

  doLast {
    println "Cleaning..."
    delete buildDir

    println "Cleaned successfully."
  }
}

tasks.register("compileFunctionalTests") {
  group = "lab"
  description = "Компиляция функциональных тестов"

  inputs.dir functionalSrcDir
  outputs.dir functionalClassesDir

  doLast {
    println "Compiling functional test classes..."

    file(functionalClassesDir).mkdirs()

    def srcFiles = fileTree(dir: functionalSrcDir, include: '**/*.java').files*.path
    if (srcFiles.isEmpty()) {
      println "No functional test sources found."
      return
    }

    def classpath = configurations.functionalTestImplementation.asPath
    def cmd = ["javac", "-d", functionalClassesDir, "-cp", classpath] + srcFiles

    exec {
      commandLine cmd
    }

    println "Functional tests compiled successfully."
  }
}

tasks.register("custom-functional-test") {
  group = "lab"
  description = "Запуск функциональных тестов"
  dependsOn("custom-build", "compileFunctionalTests")

  doLast {
    println "Running functional tests..."

    def classpath = files(
            functionalClassesDir,
            configurations.functionalTestRuntimeOnly,
            configurations.functionalTestImplementation
    ).asPath

    def cmd = [
            "java",
            "-cp", classpath,
            "org.junit.platform.console.ConsoleLauncher",
            "--scan-class-path", functionalClassesDir,
            "--details", "tree",
            "--details-theme", "ascii"
    ]

    exec {
      commandLine cmd
      ignoreExitValue = true
    }

    println "Functional tests run finished."
  }
}

tasks.register("custom-xml") {
  group = 'lab'
  description = 'Валидация всех XML-файлов в проекте'

  doLast {
    println "Validating XML-files..."
    def xmlFiles = fileTree(".") {
      include '**/*.xml'
    }

    def factory = DocumentBuilderFactory.newInstance()
    factory.setNamespaceAware(true)

    xmlFiles.each { File xmlFile ->
      try {
        def builder = factory.newDocumentBuilder()
        builder.parse(xmlFile)
        println "OK   ${xmlFile}"
      } catch (Exception e) {
        throw new GradleException("ERR: ${e}")
      }
    }

    println "All XML files are valid."
  }
}

tasks.register('custom-diff') {
  group = 'lab'
  description = 'Проверка изменений и автоматический commit отслеживаемых в gradle.properties классов'

  doLast {
    def properties = new Properties()
    file('gradle.properties').withInputStream { properties.load(it) }

    def classesToCheck = properties.getProperty('checkDiffClasses', '').split(',')

    if (classesToCheck.length == 0) {
      println "No classes to check for changes."
      return
    }

    def gitStatus = 'git status --porcelain'.execute().text
    def filesToCommit = []
    classesToCheck.each { className ->
      if (gitStatus.contains(className)) {
        filesToCommit.add(className)
      }
    }

    if (filesToCommit.isEmpty()) {
      println "No changes in specified classes."
      return
    }

    def addFilesCommand = "git add ${filesToCommit.join(' ')}".execute()
    addFilesCommand.waitFor()

    if (addFilesCommand.exitValue() == 0) {
      println "Files added to commit: ${filesToCommit}"
    } else {
      println "Error while adding files to commit: ${addFilesCommand.err.text}"
      return
    }

    def commitMessage = "Автоматический коммит изменений для классов: ${filesToCommit.join(', ')}"
    def gitCommitCommand = "git commit -m \"${commitMessage}\"".execute()

    gitCommitCommand.waitFor()

    if (gitCommitCommand.exitValue() == 0) {
      println "Commit successful."
    } else {
      println "Error while commiting: ${gitCommitCommand.exitValue()}"
    }
  }
}

dependencies {
  compileOnly('jakarta.enterprise:jakarta.enterprise.cdi-api:3.0.0')
  compileOnly('jakarta.ejb:jakarta.ejb-api:4.0.0')
  compileOnly('jakarta.persistence:jakarta.persistence-api:3.0.0')
  compileOnly('jakarta.ws.rs:jakarta.ws.rs-api:3.0.0')
  compileOnly('jakarta.servlet:jakarta.servlet-api:5.0.0')
  implementation 'jakarta.platform:jakarta.jakartaee-api:9.1.0'
  implementation 'jakarta.validation:jakarta.validation-api:2.0.2'

  implementation 'org.postgresql:postgresql:42.7.4'
  implementation 'jakarta.persistence:jakarta.persistence-api:3.1.0'
  implementation 'org.hibernate:hibernate-core:6.2.8.Final'

  implementation 'at.favre.lib:bcrypt:0.10.2'
  implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
  runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
  runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'

  testImplementation "org.junit.jupiter:junit-jupiter-api:${junitVersion}"
  testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${junitVersion}"

  compileOnly 'org.projectlombok:lombok:1.18.36'
  annotationProcessor 'org.projectlombok:lombok:1.18.36'

  testCompileOnly 'org.projectlombok:lombok:1.18.36'
  testAnnotationProcessor 'org.projectlombok:lombok:1.18.36'

  functionalTestImplementation "org.junit.platform:junit-platform-console:1.9.2"
  functionalTestImplementation "org.apiguardian:apiguardian-api:1.1.2"
  functionalTestImplementation "org.seleniumhq.selenium:selenium-java:${seleniumVersion}"

  implementation 'com.github.javaparser:javaparser-core:3.25.6'
}
